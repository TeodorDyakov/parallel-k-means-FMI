<html>
   <link rel="stylesheet" href="style.css">
   <div id = "main">
      <head>
         <title></title>
      </head>
      <body>
         <h1>Курсов проект
            По Разпределени софтуерни архитектури
         </h1>
         <h2 id ="subtitle">Задача: <span id = "">K-means clustering algorithm</span></h2>
         <!-- <h4 id = "author">Теодор Дяков</h4> -->
         <h2>1.Задание.</h2>
         <p>Задачата е да се реализира паралелна (многонишкова) имплементация на <span class = "bold">K-means</span> алгоритъма.</p>
         <p>    
         <h2>2.Какво представлява k-means алгоритъма?</h2>
         <b>K-means</b> е популярен алгоритъм в анализа на данни и машинното самообучение.
         Той извършва така наречената клъстеризация на вектори.
         Клъстеризацията представлява групиране на наблюдения (<span class = "bold">n</span>-мерни вектори в общия случай) в определен брой (<span class = "bold">k</span>) множества(клъстери) така че във всеки един клъстер векторите да бъдат близки един на друг.
         При K-means алгоритъма входните данни се състоят от <span class = "bold">m</span> ма брой наблюдения(<span class = "bold">n</span>-мерни вектори). Искаме да ги разделим в <span class = "bold">k</span> на брой  
         клъстера така, че да минимизираме дисперсията на във всеки един от тях.
         </p>
         <div id = "algorithm">
            Алгоритъм:
            Първо избираме на случаен принцип <span class = "bold">k</span> – на брой от наблюденията.
            Те ще служат като прототипи за всеки един от клъстерите.
            <p>Повтаряме <span class = "bold">p</span> на брой пъти следните две стъпки:(<span class = "bold">p</span> e хиперпараметър избран от потребителя)</p>
            <ul>
               <li><span class = "bold">Стъпка 1<i>(Assign)</i></span> – За всяко едно то наблюденията намираме на-   близкия клъстер (по Евклидова дистанция до прототипа на  клъстера) и и добавяме наблюдението към него)</li>
               <li><span class = "bold">Стъпка 2<i>(Update)</i></span> – Пресмятаме наново центровете(<span class = "bold">means</span>) на всеки от –  <span class = "bold">k</span> -на брой клъстерите.</li>
            </ul>
         </div>
         <img class = "gif" src="Kmeans.gif">
         <p class = "label">Анимация на алгоритъма в действие при k = 3.</p>
         <h2>3.Паралелизация на алгоритъма</h2>
         <p>Тъй като стъпка две от алгоритъма зависи от стъпка едно, ще паралелизираме всяка една по отделно, като ще използваме механизъм за синхронизация така че стъпка 2 да започва само ако всички нишки са приключили със стъпка 1.
            За да паралелизираме стъпка едно е достатъчно да разделим наблюденията на равни не-пресичащи се множества и да пресметнем във всяка нишка най близкия клъстер за всяко едно от тях. 
            Например ако имаме 1000 наблюдения и 4ри нишки ще ги разпределим така :
         <ul>
            <li>Нишка 1: 1-250</li>
            <li>Нишка 2: 251:500</li>
            <li>Нишка 3: 501-750</li>
            <li>Нишка 4: 751-1000</li>
         </ul>
         За втората стъпка отново ще разпределим данните по същия начин между нишките.
         При нея обаче проблем -ако използваме споделена структура за да пресмятаме центровете има опасност за race condition. Поради тази причина може да използваме техниката Divide and Conquer. Всяка нишка ще си пази центровете в своя лична несподелена структура. След като всички нишки от втора стъпка приключат работа може да сметнем центровете с просто сумиране на локалните центрове на всяка от нишките. Това ще се случи в главната нишка.</p>
         <h2>4.Синхронизация</h2>
         <p>
            В нашия алгоритъм трябва да подсигурим че на всяка итерация преминаваме към стъпка 2 само ако всички нишки са приключили работа със стъпка 1. И на всяка итерация (освен първата) искаме да започнем стъпка 1 само след като всички нишки са приключили стъпка 2. Много подходящо в случая е да се използва <span class = "bold">CountdownLatch</span>. Това и правя в моята имплементация.
         </p>
         <ul>
            <li><span class = "bold">CountdownLatch</span> – тред сейф механизъм който действа като 
               бариера с която може някоя нишка изчаква определен брой събития (сваляния на бариерата) и след това продължава работата си.
            </li>
         </ul>
         <h2> 5.Преизползване на нишки</h2>
         <p>
            Една проста реализация на алгоритъма би създавала <span class = "bold">p</span> на брой нишки за първата стъпка и <span class = "bold">p</span> на брой нишки за втората стъпка на всяка итерация от алгоритъма. (<span class = "bold">p</span> – брой логически процесори). Това означава че ако сме пуснали алгоритъма с <span class = "bold">cnt</span> на брой итерации програмата ни ще създаде общо <span class = "bold">2*p*cnt</span> на брой нишки. Това би забавило програмата когато <span class = "bold">cnt</span> е голямо, защото стартирането на една нишка включва значителен overhead както и системни извиквания. Поради тази причина е добра идея да използваме механизъм който може да преизползва вече създадени нишки. Един такъв механизъм е вграденият в Java <span class = "bold">ExecutorService</span>. По 
            По този начин ние делегираме стартирането и изпълнението на нишките към него и може да очакваме ускорение на бързодействието когато <span class = "bold">cnt</span> е значително число.
         </p>
         <h2>6.Тестване на алгоритъма</h2>
         <p>Ще тестваме алгоритъма на следната задача.
            Ще вземем снимка и ще намалим броя на цветовете в нея така че да има само 8 главни цвята(така нареченото квантуване по цветове). 
         </p>
         <div class = "flex">
            
            <div class = "flex-child">
               <img class = "testImg" src = "Parrot.jpg">
               <p class = "label">оригинално изображение</p>
            </div>

            <div class = "flex-child">
               <img class = "testImg" src = "result.jpg">
               <p class = "label">След K-Means с <b>k</b> = 8</p>
            </div>
         </div>

         <h2>7. Клас Диаграма</h2>
         <ul>
            <li><b>ParallelKmeans</b> основния клас на приложението. Той съдържа следните членове
               <ul>
                  <li><i>initializeClusters</i> - метод инициализиращ центровете на клъстерите случайно.</li>
                  <li><i>assignStep</i> - метод изпълняващ първата стъпка на алгоритъма като стартира всички <i>UpdateWorker</i> чрез <i>ExecutorService</i> и ги изчаква да приключат</li>
                  <li><i>updateStep</i> - метод изпълняващ втората стъпка на алгоритъма като стартира всички <i>AssignWorker</i> чрез <i>ExecutorService</i> и и изчаква тяхното приключване.</li>
                  <li><i>AssignWorker</i> - клас имплементиращ <i>Runnable</i>, който изпълнява първата стъпка от алгоритъма за подлист от списъка от наблюдения. </li>
                  <li><i>UpdateWorker</i> - клас имплементиращ <i>Runnable</i>, който изпълнява втората стъпка от алгоритъма за подлист на списъка от наблюдения. </li>
                  <li><i>Observation</i>  - клас който предтавлява наблюдение. То се състои от:
                  <ul>
                     <li><i>vec</i> - вектор от реални числа</li>
                     <li><i>cluster</i> - число указващo към кой клъстер принадлежи наблюдението.</i>   
                  </ul>
               </ul>
            <li><b>VectorMath</b> - аритметични функции за вектори</li>
            <li><b>Demo</b> - демо на програмата което извършва обработката на изображение по показания в част 6 начин.</li>
         </ul>
         <img class = "gif" src = "class_diagram.png">
         <p class="label">Клас диаграма на Java кода в проекта</p>
      </body>
   </div>
</html>