<html>
<link rel="stylesheet" href="style.css">
<div id="main">

   <head>
      <title></title>
   </head>

   <body>
      <h1>Курсов проект
         По Разпределени софтуерни архитектури
      </h1>
      <h2 id="subtitle">Задача: <span id="">Паралелен K-means clustering algorithm</b></h2>
      <h2>1.Задание.</h2>
      <p>Задачата е да се реализира паралелна (<b>многонишкова</b>) имплементация на <b>K-means</b> алгоритъма.</p>

      <h2>2.Какво представлява k-means алгоритъма?</h2>
      <p><b>K-means</b> е популярен алгоритъм в анализа на данни и машинното самообучение.
         Той извършва така наречената клъстеризация на вектори.
         Клъстеризацията представлява групиране на наблюдения (<b>n</b>-мерни вектори в общия случай) в определен брой
         (<b>k</b>) множества(клъстери) така че във всеки един клъстер векторите да бъдат близки един на друг.<br>
         При K-means алгоритъма входните данни се състоят от <b>m</b> наблюдения(<b>n</b>-мерни вектори). Искаме да ги
         разделим в <b>k</b> на брой
         клъстера така, че да минимизираме </b>дисперсията</b> на във всеки един от тях.
      </p>
      <div id="algorithm">
         Алгоритъм:
         Първо избираме на случаен принцип <b>k</b> – на брой от наблюденията.
         Те ще служат като прототипи за всеки един от клъстерите.
         <p>Повтаряме <b>p</b> на брой пъти следните две стъпки:(<b>p</b> e параметър избран от потребителя)</p>
         <ul>
            <li><b>Стъпка 1<i>(Assign)</i></b> – За всяко едно от наблюденията намираме най-близкия клъстер (по
               Евклидово разстояние до прототипа на клъстера) и и добавяме наблюдението към него</li>
            <li><b>Стъпка 2<i>(Update)</i></b> – Пресмятаме наново прототипите на клъстерите. Новите прототипи ще бъдат
               центровете(<b>means</b>) на всеки от – <b>k</b> -на брой клъстерите.</li>
         </ul>
      </div>
      <img class="gif" src="images/Kmeans.gif">
      <p class="label">Анимация на алгоритъма в действие при k = 3.</p>
      <h2>3.Паралелизация на алгоритъма</h2>
      <p>Тъй като стъпка две от алгоритъма зависи от стъпка едно, ще паралелизираме всяка една по отделно, като ще
         използваме механизъм за синхронизация така че стъпка 2 да започва само ако всички нишки са приключили със
         стъпка 1.
         За да паралелизираме стъпка едно е достатъчно да разделим наблюденията на равни не-пресичащи се множества и да
         пресметнем във всяка нишка най близкия клъстер за всяко едно от тях.
         Например ако имаме 1003 наблюдения и 4 нишки ще ги разпределим така :
      <table>
         <tr>
            <th>Нишка 1</th>
            <th>Нишка 2</th>
            <th>Нишка 3</th>
            <th>Нишка 4</th>
         </tr>
         <tr>
            <th>1-250</th>
            <th>251-500</th>
            <th>501-750</th>
            <th>751-1003</th>
         </tr>
      </table>
      За втората стъпка отново ще разпределим данните по същия начин между нишките.
      При нея обаче проблем -ако използваме споделена структура за да пресмятаме центровете има опасност за <b>race
         condition</b>. Поради тази причина използвам техниката <b>Divide and Conquer</b>. Всяка нишка ще си пази
      центровете в своя лична несподелена структура. След като всички нишки от втора стъпка приключат работа може да
      сметнем центровете с просто сумиране на локалните центрове на всяка от нишките. Това ще се случи в главната нишка.
      </p>
      <h2>4.Синхронизация</h2>
      <p>
         В нашия алгоритъм трябва да подсигурим че на всяка итерация преминаваме към <b>стъпка 2</b> само ако всички
         нишки са приключили работа със <b>стъпка 1</b>. И на всяка итерация (освен първата) искаме да започнем
         <b>стъпка 1</b> само след като всички нишки са приключили <b>стъпка 2</b>. Много подходящо в случая е да се
         използва <b>CountdownLatch</b>. Това и правя в моята имплементация.
      </p>
      <ul>
         <li><b>CountdownLatch</b> – (отброяващо резе) - тред сейф механизъм който действа като
            резе с която може някоя нишка изчаква определен брой събития (отброявания на резето) и след това продължава
            работата си.
         </li>
      </ul>
      <h2> 5.Преизползване на нишки</h2>
      <p>
         Една проста реализация на алгоритъма би създала <b>p</b> на брой нишки за първата стъпка и <b>p</b> на брой
         нишки за втората стъпка на всяка итерация от алгоритъма. (<b>p</b> – брой логически процесори). Това означава
         че ако алгоритъма се пусне с <b>cnt</b> на брой итерации програмата ще създаде общо <b>2*p*cnt</b> на брой
         нишки. Това би забавило програмата когато <b>cnt</b> е голямо, защото стартирането на една нишка включва
         значителен overhead както и системни извиквания. Поради тази причина е добра идея да се използва механизъм
         който може да преизползва вече създадени нишки. Един такъв механизъм е вграденият в Java
         <b>ExecutorService</b>. По
         По този начин ние делегираме стартирането и изпълнението на нишките към него и може да очакваме ускорение на
         бързодействието когато <b>cnt</b> е значително число.
      </p>
      <h2>6.Тестване на алгоритъма</h2>
      <p>Бързодействието на алгоритъма бе проверено на следната задача.
         Тестовата прграма зарежда снимка и я трансформира така че да намали броя на цветовете в нея до точно определен
         брой избран от потребителя(така нареченото квантуване по цветове). В програмата това число беше <b>8</b>. Тъй
         като всеки цвят в <b>RGB</b> има 3 компонента (red, green, blue) всеки пиксел може да се представи като 3-мерен
         вектор. Така задачата се свежда до клъстеризиране на пикселите в изображението в 8 клъстера, като всеки клъстер
         съответсва на един от главните цветове в изображението.
         </p>
         <h4>Машина 1 - Notebook за работа с 4 ядра</h4>
      <p>Експеримента бе проведен с брой на нишките от 1 до 8. Параметрите на машината на на която тествах са
         следните
      </p>
      <table id="cpu">
         <tr>
            <th>модел процесор</th>
            <td>Intel® Core™ i3-1005G1 Processor</td>
         </tr>
         <tr>
            <th>честота</th>
            <td>1.20 GHz</td>
         </tr>
         <tr>
            <th>физически ядра</th>
            <td>2</td>
         </tr>
         <tr>
            <th>логически ядра</th>
            <td>4</td>
         </tr>
         <tr>
            <th>Кеш</th>
            <td>4 MB Intel® Smart Cache</td>
         </tr>
         <tr>
            <th>ОС</th>
            <td>Linux Ubuntu 20.04</td>
         </tr>
      </table>
      <p>Резултатите от експеримента при брой итерации в алгоритъма = 50 бяха:</p>
      <table id="results">
         <tr>
            <th>Брой нишки</th>
            <td>1</td>
            <td>2</td>
            <td>3</td>
            <td>4</td>
            <td>5</td>
            <td>6</td>
            <td>7</td>
            <td>8</td>
         </tr>
         <tr>
            <th>Време за изпълнение (ms)</th>
            <td>7052</td>
            <td>4777</td>
            <td>4498</td>
            <td>4095</td>
            <td>4580</td>
            <td>4313</td>
            <td>4302</td>
            <td>4116</td>
         </tr>
         <tr>
            <th>speedup</th>
            <td>1</td>
            <td>1.48</td>
            <td>1.57</td>
            <td>1.72</td>
            <td>1.54</td>
            <td>1.64</td>
            <td>1.64</td>
            <td>1.71</td>
         </tr>
      </table>

      <img class="gif" src="images/graphRSA.png">
      <div class="flex">
         <div class="flex-child">
            <img class="testImg" src="images/Parrot.jpg">
            <p class="label">оригинално изображение</p>
         </div>

         <div class="flex-child">
            <img class="testImg" src="images/result.jpg">
            <p class="label">След K-Means с <b>k</b> = 8</p>
         </div>
      </div>

      <h4>Сървърна машина с 16 ядра</h4>
      <p>
         Програмата беше тествана и на машина със 16 ядра(16 физически и 32 логически), намираща се на адрес
         t5600.rmi.yaht.net . Бяха проведени експеримети с до 32 нишки.
      </p>

      <table class="tableizer-table">
         <thead>
            <tr class="tableizer-firstrow">
               <th>Брой нишки</th>
               <th>1</th>
               <th>2</th>
               <th>3</th>
               <th>4</th>
               <th>5</th>
               <th>6</th>
               <th>7</th>
               <th>8</th>
               <th>9</th>
               <th>10</th>
               <th>11</th>
               <th>12</th>
               <th>13</th>
               <th>14</th>
               <th>15</th>
               <th>16</th>
            </tr>
         </thead>
         <tbody>
            <tr>
               <td>Време(ms)</td>
               <td>19226</td>
               <td>8452</td>
               <td>7420</td>
               <td>4505</td>
               <td>4280</td>
               <td>4022</td>
               <td>2714</td>
               <td>2439</td>
               <td>2224</td>
               <td>2414</td>
               <td>2817</td>
               <td>2221</td>
               <td>2339</td>
               <td>2246</td>
               <td>1854</td>
               <td>1844</td>
            </tr>
            <tr>
               <td>Speedup</td>
               <td>1</td>
               <td>2,27</td>
               <td>2,59</td>
               <td>4,26</td>
               <td>4,49</td>
               <td>4,78</td>
               <td>7,08</td>
               <td>7,88</td>
               <td>8,64</td>
               <td>7,96</td>
               <td>6,82</td>
               <td>8,65</td>
               <td>8,21</td>
               <td>8,56</td>
               <td>10,37</td>
               <td>10,42</td>
            </tr>
         </tbody>
      </table>

      <table class="tableizer-table">
         <thead>
            <tr class="tableizer-firstrow">
               <th>Брой нишки</th>
               <th>17</th>
               <th>18</th>
               <th>19</th>
               <th>20</th>
               <th>21</th>
               <th>22</th>
               <th>23</th>
               <th>24</th>
               <th>25</th>
               <th>26</th>
               <th>27</th>
               <th>28</th>
               <th>29</th>
               <th>30</th>
               <th>31</th>
               <th>32</th>
            </tr>
         </thead>
         <tbody>
            <tr>
               <td>Време(ms)</td>
               <td>1969</td>
               <td>1942</td>
               <td>1509</td>
               <td>1495</td>
               <td>1469</td>
               <td>1420</td>
               <td>1407</td>
               <td>1405</td>
               <td>1350</td>
               <td>1452</td>
               <td>1373</td>
               <td>1377</td>
               <td>1376</td>
               <td>1375</td>
               <td>1317</td>
               <td>1336</td>
            </tr>
            <tr>
               <td>Speedup</td>
               <td>9,76</td>
               <td>9,9</td>
               <td>12,74</td>
               <td>12,86</td>
               <td>13,08</td>
               <td>13,53</td>
               <td>13,66</td>
               <td>13,68</td>
               <td>14,24</td>
               <td>13,24</td>
               <td>14</td>
               <td>13,96</td>
               <td>13,97</td>
               <td>13,98</td>
               <td>14,59</td>
               <td>14,39</td>
            </tr>
         </tbody>
      </table>
      <img class = "gif" id = "server_chart" src = "images/Line_chart_time_ms.png">

      <h2>7. Клас Диаграма</h2>
      <ul>
         <li><b>ParallelKmeans</b> основния клас на приложението. Той съдържа следните членове
            <ul>
               <li><i>initializeClusters</i> - метод инициализиращ центровете на клъстерите случайно.</li>
               <li><i>assignStep</i> - метод изпълняващ първата стъпка на алгоритъма като стартира всички
                  <i>AssignWorker</i> чрез <i>ExecutorService</i> и ги изчаква да приключат
               </li>
               <li><i>updateStep</i> - метод изпълняващ втората стъпка на алгоритъма като стартира всички
                  <i>UpdateWorker</i> чрез <i>ExecutorService</i> и и изчаква тяхното приключване.
               </li>
               <li><i>AssignWorker</i> - клас имплементиращ <i>Runnable</i>, който изпълнява първата стъпка от
                  алгоритъма за подлист от списъка от наблюдения. </li>
               <li><i>UpdateWorker</i> - клас имплементиращ <i>Runnable</i>, който изпълнява втората стъпка от
                  алгоритъма за подлист на списъка от наблюдения. </li>
               <li><i>Observation</i> - клас който представлява наблюдение. То се състои от:
                  <ul>
                     <li><i>vec</i> - вектор от реални числа</li>
                     <li><i>cluster</i> - число указващo към кой клъстер принадлежи наблюдението.</i>
                  </ul>
            </ul>
         <li><b>VectorMath</b> - аритметични функции за вектори</li>
         <li><b>Demo</b> - демо на програмата което извършва обработката на изображение по показания в част 6 начин.
         </li>
      </ul>
      <img class="gif" src="images/class_diagram.png">
      <p class="label">Клас диаграма на Java кода в проекта</p>
   </body>
</div>

</html>