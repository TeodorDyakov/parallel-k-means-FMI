<html>
   <link rel="stylesheet" href="style.css">
   <div id = "main">
      <head>
         <title></title>
      </head>
      <body>
         <h1>Курсов проект
            По Разпределени софтуерни архитектури
         </h1>
         <h2 id ="subtitle">Задача: <span id = "">K-means clustering algorithm</b></h2>
         <!-- <h4 id = "author">Теодор Дяков</h4> -->
         <h2>1.Задание.</h2>
         <p>Задачата е да се реализира паралелна (многонишкова) имплементация на <b>K-means</b> алгоритъма.</p>
         <p>    
         <h2>2.Какво представлява k-means алгоритъма?</h2>
         <b>K-means</b> е популярен алгоритъм в анализа на данни и машинното самообучение.
         Той извършва така наречената клъстеризация на вектори.
         Клъстеризацията представлява групиране на наблюдения (<b>n</b>-мерни вектори в общия случай) в определен брой (<b>k</b>) множества(клъстери) така че във всеки един клъстер векторите да бъдат близки един на друг.
         При K-means алгоритъма входните данни се състоят от <b>m</b> наблюдения(<b>n</b>-мерни вектори). Искаме да ги разделим в <b>k</b> на брой  
         клъстера така, че да минимизираме дисперсията на във всеки един от тях.
         </p>
         <div id = "algorithm">
            Алгоритъм:
            Първо избираме на случаен принцип <b>k</b> – на брой от наблюденията.
            Те ще служат като прототипи за всеки един от клъстерите.
            <p>Повтаряме <b>p</b> на брой пъти следните две стъпки:(<b>p</b> e параметър избран от потребителя)</p>
            <ul>
               <li><b>Стъпка 1<i>(Assign)</i></b> – За всяко едно от наблюденията намираме най-близкия клъстер (по Евклидово разстояние до прототипа на  клъстера) и и добавяме наблюдението към него</li>
               <li><b>Стъпка 2<i>(Update)</i></b> – Пресмятаме наново прототипите на клъстерите. Новите прототипи ще бъдат центровете(<b>means</b>) на всеки от –  <b>k</b> -на брой клъстерите.</li>
            </ul>
         </div>
         <img class = "gif" src="Kmeans.gif">
         <p class = "label">Анимация на алгоритъма в действие при k = 3.</p>
         <h2>3.Паралелизация на алгоритъма</h2>
         <p>Тъй като стъпка две от алгоритъма зависи от стъпка едно, ще паралелизираме всяка една по отделно, като ще използваме механизъм за синхронизация така че стъпка 2 да започва само ако всички нишки са приключили със стъпка 1.
            За да паралелизираме стъпка едно е достатъчно да разделим наблюденията на равни не-пресичащи се множества и да пресметнем във всяка нишка най близкия клъстер за всяко едно от тях. 
            Например ако имаме 1000 наблюдения и 4ри нишки ще ги разпределим така :
         <ul>
            <li>Нишка 1: 1-250</li>
            <li>Нишка 2: 251:500</li>
            <li>Нишка 3: 501-750</li>
            <li>Нишка 4: 751-1000</li>
         </ul>
         За втората стъпка отново ще разпределим данните по същия начин между нишките.
         При нея обаче проблем -ако използваме споделена структура за да пресмятаме центровете има опасност за <b>race condition</b>. Поради тази причина използвам техниката <b>Divide and Conquer</b>. Всяка нишка ще си пази центровете в своя лична несподелена структура. След като всички нишки от втора стъпка приключат работа може да сметнем центровете с просто сумиране на локалните центрове на всяка от нишките. Това ще се случи в главната нишка.</p>
         <h2>4.Синхронизация</h2>
         <p>
            В нашия алгоритъм трябва да подсигурим че на всяка итерация преминаваме към <b>стъпка 2</b> само ако всички нишки са приключили работа със <b>стъпка 1</b>. И на всяка итерация (освен първата) искаме да започнем <b>стъпка 1</b> само след като всички нишки са приключили <b>bстъпка 2</b>. Много подходящо в случая е да се използва <b>CountdownLatch</b>. Това и правя в моята имплементация.
         </p>
         <ul>
            <li><b>CountdownLatch</b> – (отброяващо резе) - тред сейф механизъм който действа като 
               резе с която може някоя нишка изчаква определен брой събития (отброявания на резето) и след това продължава работата си.
            </li>
         </ul>
         <h2> 5.Преизползване на нишки</h2>
         <p>
            Една проста реализация на алгоритъма би създала <b>p</b> на брой нишки за първата стъпка и <b>p</b> на брой нишки за втората стъпка на всяка итерация от алгоритъма. (<b>p</b> – брой логически процесори). Това означава че ако алгоритъма се пусне с <b>cnt</b> на брой итерации програмата ще създаде общо <b>2*p*cnt</b> на брой нишки. Това би забавило програмата когато <b>cnt</b> е голямо, защото стартирането на една нишка включва значителен overhead както и системни извиквания. Поради тази причина е добра идея да се използва механизъм който може да преизползва вече създадени нишки. Един такъв механизъм е вграденият в Java <b>ExecutorService</b>. По 
            По този начин ние делегираме стартирането и изпълнението на нишките към него и може да очакваме ускорение на бързодействието когато <b>cnt</b> е значително число.
         </p>
         <h2>6.Тестване на алгоритъма</h2>
         <p>Бързодействието на алгоритъма бе проверено на следната задача.
            Тестовата прграма зарежда снимка и я трансформира така че да намали броя на цветовете в нея до точно определен брой избран от потребителя(така нареченото квантуване по цветове). В програмата това число беше <b>8</b>. Тъй като всеки цвят в <b>RGB</b> има 3 компонента (red, green, blue) всеки пиксел може да се представи като 3-мерен вектор. Така задачата се свежда до клъстеризиране на пикселите в изображението в 8 клъстера, като всеки клъстер съответсва на един от главните цветове в изображението.
            <br/>Експеримента бе проведен с брой на нишките от 1 до 8. Параметрите на машината на на която тествах са следните
         </p>
         <table id = "cpu">
            <tr>
               <th>модел процесор</th>
               <td>Intel® Core™ i3-1005G1 Processor</td>
            </tr>
            <tr>
            <th>честота</th>
            <td>1.20 GHz</td>
            </tr>
            <tr>
               <th>физически ядра</th>
               <td>2</td>
            </tr>
            <tr>
               <th>логически ядра</th>
               <td>4</td>
            </tr>
            <tr>
               <th>Кеш</th>
               <td>4 MB Intel® Smart Cache</td>
            </tr>
            <tr>
               <th>ОС</th>
               <td>Linux Ubuntu 20.04</td>
            </tr>
         </table>
         <p>Резултатите от експеримента при брой итерации в алгоритъма = 50 бяха:</p>
         <table id = "results">
           <tr>
               <th>Брой нишки</th>
               <td>1</td>
               <td>2</td>
               <td>3</td>
               <td>4</td>
               <td>5</td>
               <td>6</td>
               <td>7</td>
               <td>8</td>
            </tr>
            <tr>
               <th>Време за изпълнение (ms)</th>
               <td>7052</td>
               <td>4777</td>
               <td>4498</td>
               <td>4095</td>
               <td>4580</td>
               <td>4313</td>
               <td>4302</td>
               <td>4116</td>
            </tr>
            <tr>
               <th>speedup</th>
               <td>1</td>
               <td>1.48</td>
               <td>1.57</td>
               <td>1.72</td>
               <td>1.54</td>
               <td>1.64</td>
               <td>1.64</td>
               <td>1.71</td>
            </tr>
         </table>
         <img class = "gif" src = "graphRSA.png">
         <div class = "flex">   
            <div class = "flex-child">
               <img class = "testImg" src = "Parrot.jpg">
               <p class = "label">оригинално изображение</p>
            </div>

            <div class = "flex-child">
               <img class = "testImg" src = "result.jpg">
               <p class = "label">След K-Means с <b>k</b> = 8</p>
            </div>
         </div>

         <h2>7. Клас Диаграма</h2>
         <ul>
            <li><b>ParallelKmeans</b> основния клас на приложението. Той съдържа следните членове
               <ul>
                  <li><i>initializeClusters</i> - метод инициализиращ центровете на клъстерите случайно.</li>
                  <li><i>assignStep</i> - метод изпълняващ първата стъпка на алгоритъма като стартира всички <i>AssignWorker</i> чрез <i>ExecutorService</i> и ги изчаква да приключат</li>
                  <li><i>updateStep</i> - метод изпълняващ втората стъпка на алгоритъма като стартира всички <i>UpdateWorker</i> чрез <i>ExecutorService</i> и и изчаква тяхното приключване.</li>
                  <li><i>AssignWorker</i> - клас имплементиращ <i>Runnable</i>, който изпълнява първата стъпка от алгоритъма за подлист от списъка от наблюдения. </li>
                  <li><i>UpdateWorker</i> - клас имплементиращ <i>Runnable</i>, който изпълнява втората стъпка от алгоритъма за подлист на списъка от наблюдения. </li>
                  <li><i>Observation</i>  - клас който предтавлява наблюдение. То се състои от:
                  <ul>
                     <li><i>vec</i> - вектор от реални числа</li>
                     <li><i>cluster</i> - число указващo към кой клъстер принадлежи наблюдението.</i>   
                  </ul>
               </ul>
            <li><b>VectorMath</b> - аритметични функции за вектори</li>
            <li><b>Demo</b> - демо на програмата което извършва обработката на изображение по показания в част 6 начин.</li>
         </ul>
         <img class = "gif" src = "class_diagram.png">
         <p class="label">Клас диаграма на Java кода в проекта</p>
      </body>
   </div>
</html>